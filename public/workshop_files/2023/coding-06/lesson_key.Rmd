
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Welcome to the correlations and basic visuals workshop! 

# Links to Files and Video Recording

The files for all tutorials can be downloaded from [SIPPS website](https://columbia-sipps.github.io/workshops/){target="_blank"}. The recordings from this session will also be posted on the same site. 

# Goals of this lesson

Students will learn:

1. Intro to the ggplot package and how to use it 
2. How to construct some common plots to inspect data: namely, histograms, bar plots, and scatter plots
3. How to compute (and visualize) the correlation between two variables

# Inspecting a dataset 

So far, we've seen how to clean, rename and filter data in a way that prepares it for further analyses (such as modeling). But one important step before we move into that is learning how to visualize your data. Plots are critical for helping you look at the data, allowing you to visually inspect for any outliers or errors, assess the shape of your data distributions, and evaluate whether the data looks "clean" or if it needs any additional cleaning or transformations. 

First, let's load in some data. This time we're going to look at characteristics of top songs on Spotify between 2000-2019.

See here for more information: https://www.kaggle.com/datasets/paradisejoy/top-hits-spotify-from-20002019 

```{r}

library(tidyverse)

songs <- read.csv(file = 'spotify_data.csv', stringsAsFactors = F)
head(songs)

```

As you can see when looking at the data, in addition to some basic information about each song (e.g., artist, year, duration), we have information about several qualities of music that Spotify keeps track of (e.g., energy, "speechiness").

Let's get the names of all the columns, as well as the number of columns and rows (i.e., songs).

```{r}

# we can also get the names of columns, number of columns and number of rows
names(songs)
nrow(songs)
ncol(songs)

```

Let's say the first thing we want to look at his how long popular songs tend to be. The column we need for this is `duration_ms`, which contains each song's duration in milliseconds. To make this a bit easier to comprehend, let's start by converting the duration to seconds.

```{r}

# add a new column for duration in seconds
songs$duration_s <- songs$duration_ms / 1000

```

Now, the simplest way to visualize a single continuous variable like this is by looking at its distribution. We can do that by plotting a **histogram**. 

```{r}

hist(songs$duration_s)

```

Okay, what do you notice looking at this plot? 

We can see that it ranges from 100 to approx 500. We can see that most songs are somewhere between 200-250 seconds (roughly between 3-4 minutes), but that there are some songs that are quite a bit longer or shorter.

We can also confirm the exact range of these values using the `range()` function.

```{r}

range(songs$duration_s)

```

The other thing you might notice is that this plot isn't all that pretty. How can we fix that?

Let's start by changing the colors of our plot, and also changing the number of bins we're using.

```{r}

hist(songs$duration_s, col = "blue", breaks = 2)

```

Oops! This only has 2 breaks, which means there are only 2 bins. That's probably not the best way to look at this. So let's try different values of breaks.

```{r}

hist(songs$duration_s, col = "blue", breaks = 20)

```

That's better. Now let's add a title to the plot, and change what the x axis is called so it's more descriptive.

```{r}

hist(songs$duration_s, col = "blue", breaks = 20, main = "histogram of top song durations", xlab = "song duration (s)")

```

One thing you might have noticed here is that each time we wanted to change one aspect of the visualization, we had to basically rewrite the same function, adding a lot more arguments. If you really wanted to customize all the aspects of a plot, you might be able to imagine how complicated this could get. Your function would get really long with a ton of arguments. 

# Enter the `ggplot2` package of `tidyverse`

The first few code chunks will return results that look exactly like the plots above, but with ggplot, you can do A LOT more visually. This is what I ALWAYS use. Base R functions can be good when you are trying to get a quick and dirty visual of your data, but if you are looking to create visuals that are suitable for a paper, presentation, portfolio, etc., you want to use ggplot.

Some basic properties of `ggplot2`:

* you'll always use the `ggplot()` command first to start building your plot

* plots can be saved into variables with `a <- ggplot()`

* the general format of this function is `ggplot(data, aes(x = [x axis variable], y = [y axis variable])` 
    * x and y variables are always specified in this `aes()` subfunction
    * some types of plots may require additional `aes()` arguments, may only need an x variable, etc.

First things first,  let's load the package `tidyverse`

```{r}

library(tidyverse)
# we could also load in just the ggplot2 package using library(ggplot2)
# however, it typically makes sense to load the entire tidyverse since we'll also be cleaning and analyzing our data

```

Now run this line of code:

```{r}

ggplot(data = songs, aes(x = duration_s))

```
  
  What do you notice? 
  
  * first, axes are set up the way we'd expect, and seem to have sensible values
  * however, why is nothing on this graph yet? we haven't put any graphic actually on the axes yet!

**We need to tell the `ggplot()` call what kind of graphic to put on the axis!**

  * a lot of the time, the syntax we'll use to add elements to our plot is `geom_[something]`

## Histograms

So let's try building a histogram with `geom_histogram()`: 

```{r}

ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "blue")
  
```

We can easily change multiple aesthetics of the plot by adding more arguments to our geom_histogram function.

Note that when using ggplot, the `fill` argument usually controls the color *inside* a plotting element, whereas `color` controls the border around it. For some plotting elements, like the bars in a histogram, you can modify both of these properties. In other cases, you may only be able to modify one or the other.


```{r}

ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "blue", color = "black")

```

You can also add titles and axis labels just like we did above — but in a manner that's easier to read. Specifically, you can use the function `labs()` to give the plot a title, label your axes, and more. 

```{r}

ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "blue", color = "black") + 
  labs(x = "song duration (s)", 
       title = "Histogram of tooth lengths")

```

You can use the `bins` argument to change the number of bins (like breaks above). Try different values of bins and see how it changes your plot!

```{r}

ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "blue", color = "black", bins = 20) + 
  labs(x = "tooth length", 
       title = "histogram of top song durations")

```

## ggplot themes

As we've mentioned, ggplot allows a great deal of flexibility in terms of modifying the style and appearance of your plots. One obvious adjustment you might want to make to your plots is changing the colors, which we've already introduced.

However, beyond the basic, nameable colors (e.g., "red", "blue"), you can tell ggplot to use a huge number of built-in colors (see this page: http://sape.inf.usi.ch/sites/default/files/ggplot2-colour-names.png), or even enter a custom hex code (e.g., #FFFFFF = white).

```{r}

ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "aquamarine3", color = "aquamarine4", bins = 20) + 
  labs(x = "song duration (s)", 
       title = "histogram of top song durations")

```

ggplot also includes many built-in **themes**, which change elements such as your plot's grid lines, borders, and so on. (You can also create and save your own custom themes, for even more flexibility!)

```{r}

# to easily see how themes work, let's start by saving our current plot into a variable (called myplot)
myplot <- ggplot(data = songs, aes(x = duration_s)) +
  geom_histogram(fill = "aquamarine2", color = "aquamarine4", bins = 20) + 
  labs(x = "song duration (s)", 
       title = "histogram of top song durations")

# now you can see the plot by calling the name of this variable
myplot

# let's try some themes!
myplot + labs(subtitle = 'theme: bw') + theme_bw()
myplot + labs(subtitle = 'theme: minimal') + theme_minimal()
myplot + labs(subtitle = 'theme: void') + theme_void()
myplot + labs(subtitle = 'theme: classic') + theme_classic()
myplot + labs(subtitle = 'theme: classic') + theme_light()

```

Check out this link for more comprehensive info about all the themes ggplot has to offer: https://ggplot2.tidyverse.org/reference/ggtheme.html

You can also create your own custom theme, or download packages created by other R users that contain additional themes. The customization options are limitless!

# Bar plots

Now that we've learned a little more about plot customization, let's see what other kinds of visualizations we can make! Histograms are generally great for visualizing distributions of individual variables, but they're not great for telling us about the relationship between two (or more) variables.

For this kind of purpose, one of the most commonly-used types of plots is something you've probably seen before: a bar plot. Bar plots are great for looking at how values of one outcome variable differ as a function of a variable that can be split into discrete categories.

To make this explicit, let's say we want to look at the average "danceability" of a song as a function of whether it's considered "explicit" according to Spotify.

```{r}

# we again need to start with the ggplot() function, but this time we'll use geom_bar() to build on top of it
# notice how we need to specify a y variable in the aes() function, since bar plots need both an x and y

ggplot(data = songs, aes(x = explicit, y = danceability)) +
  geom_bar(stat = "summary", fun.y = "mean")

```

Interesting! From our plot it looks like songs that are explicit in some way tend to be a bit more danceable. Let's add a bit more customization to make the plot look better:

```{r}

# adding the "width" argument to geom_bar() makes the bars a bit thinner
# adding "fill = explicit" to our aes() function makes ggplot change the color of the bars based on that variable

ggplot(data = songs, aes(x = explicit, y = danceability, fill = explicit)) +
  geom_bar(stat = "summary", width = 0.7) +
  labs(x = 'explicit category', y = 'average song danceability')
  
  
```

Bar plots can also help us visualize how an outcome variable (y) differs based on two different categorical variables. Let's say we want to see how song danceability differs not only based on whether a song is explicit or not, but also based on which decade (2000s or 2010s) the song came from.

All we need to do in our plot is choose one of these variables to go on our x-axis, and the other to be depicted in the *fill* of each bar.

```{r}

# first let's make this new decade variable
songs <- songs %>%
  mutate(decade = ifelse(year < 2010, '2000s', '2010s'))

# the mutate() function can be used for adding new columns to a dataframe or changing existing ones
# the ifelse() function here is saying that IF the value of the "year" column is less than 2010, the value
#   of the new "decade" column should be "2000s"; if not, it should be "2010s"

ggplot(data = songs, aes(x = explicit, y = danceability, fill = decade)) +
  geom_bar(stat = "summary", width = 0.7, position = position_dodge()) +
  labs(x = 'explicit category', y = 'average song danceability')
  
# we need the position = position_dodge() argument to make sure that our 2 bar types aren't stacked on top of each other

```

You can also make bar plots of variables with many more than two levels. For one last example, let's make a bar plot where we look at the average song danceability again, but this time as a function of which year it was released.

```{r}

ggplot(data = songs, aes(x = year, y = danceability, fill = year)) +
  geom_bar(stat = "summary", width = 0.7, position = position_dodge()) +
  labs(x = 'year',
       y = 'average song danceability',
       title = 'length of popular songs between 2000-2019') +
  theme_light() +
  theme(legend.position = 'none') # get rid of the legend, because it's redundant in this plot
  
```

Looks like popular songs have gotten a little more danceable on average over the past few years!

# Scatterplots

Scatterplots are very useful for looking at the relationship between two **continuous** variables. Let's say we're interested in how the "energy" of a song (another song characteristic calculated by Spotify) relates to its tempo (i.e., how fast it is).

To build a scatterplot, we can use the `geom_point()` function.

```{r}

ggplot(data = songs, aes(x = tempo, y = energy)) + 
  geom_point()

```

Unsurprisingly, we can do a lot of customization to this plot, if we want! Let's do a few things:

- add better labels
- make the points a different color
- make the points a smaller size
- make the points slightly transparent (via the "alpha" argument)
- change the theme

```{r}

ggplot(data = songs, aes(x = tempo, y = energy)) + 
  labs(x = 'song tempo (BPM)', y = 'song energy', ) +
  geom_point(color = 'dodgerblue2', size = 1, alpha = 0.5) +
  theme_light()

# NOTE: the order that you add things (with the + sign) to a ggplot object typically doesn't matter!
# the only time it *does* matter is if you're building successive plot elements on top of each other
# for example, if you want to overlay individual data points on top of a bar plot, you want to
# add the geom_point() function *after* the geom_bar() function

```

## Quantifying our scatterplot with correlations

From the plot above, we can *kind of* see that our two variables might have a meaningful relationship to each other: songs that have higher energy tend to have slightly faster tempos. But how do we actually quantify this effect? This is where **correlations** come in as a useful statistical tool.

Correlations, generally speaking, measure how strongly two (continuous) variables co-vary with each other. Positive correlations indicate that as one variable increases, so does the other. Negative correlations indicate that as one variable increases, the other decreases. All correlation values (also called r values) exist in a range between -1 and 1, with 0 indicating *no* reliable relationship between one variable and the other.

Computing correlations in R, thankfully, is very easy using the `cor.test()` function.

```{r}

cor.test(songs$energy, songs$tempo) # order of these arguments doesn't matter

# you can also compute the correlation value alone, without assessing significance, with the cor() function
cor(songs$energy, songs$tempo)

```

We can see from the p-value here that this correlation is highly significant (p < 0.001), with a correlation (r) value of 0.15. This reaffirms what we saw in our scatterplot: as song energy goes up, so does tempo.

## Visualizing the line of best fit

When plotting correlations, many researchers will include a "line of best fit", which just refers to the straight line that best characterizes the relationship between your two variables, given your data. This line is technically calculated by running a linear regression analysis (not a correlation — although with only two variables, the two analyses are highly related to each other).

You'll cover linear regression in more depth during a later workshop, but lucky for us, ggplot has a built in function that creates this line very easily!

```{r}

ggplot(data = songs, aes(x = tempo, y = energy)) + 
  labs(x = 'song tempo (BPM)', y = 'song energy', ) +
  geom_point(color = 'dodgerblue2', size = 1, alpha = 0.5) +
  geom_smooth(method = 'lm', color = 'dodgerblue4', fill = 'dodgerblue4', alpha = 0.2) + # this line adds the regression line!
  theme_light()

```

# More about ggplot

In a single workshop, we can only scratch the surface of what can be done with ggplot! There are many many more kinds of plots and customization options to explore, which you can choose based on your visualization needs. Always feel free to get in touch with your mentor(s) + instructor(s) if you have questions about what plots are best suited for your data, or if you have any other questions.

In the meantime, here are some initial resources to check out:

- ggplot cheat sheet: https://www.maths.usyd.edu.au/u/UG/SM/STAT3022/r/current/Misc/data-visualization-2.1.pdf
- ggplot gallery: https://www.r-graph-gallery.com/ggplot2-package.html
- more visualization examples: http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html


